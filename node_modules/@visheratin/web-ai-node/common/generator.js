"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = exports.encodeData = exports.GeneratorType = void 0;
const ort = __importStar(require("onnxruntime-common"));
var GeneratorType;
(function (GeneratorType) {
    GeneratorType[GeneratorType["Unknown"] = 1] = "Unknown";
    GeneratorType[GeneratorType["Img2Seq"] = 2] = "Img2Seq";
    GeneratorType[GeneratorType["Seq2Seq"] = 3] = "Seq2Seq";
})(GeneratorType || (exports.GeneratorType = GeneratorType = {}));
const encodeData = async (imageEncoder, imageInput, imageAttention, textEncoder, textInput, textAttention) => {
    if (!imageEncoder && !textEncoder) {
        throw new Error("At least one encoder should be provided");
    }
    let imageOutput = undefined;
    if (imageEncoder) {
        if (!imageInput) {
            throw new Error("Image input is not provided");
        }
        imageOutput = await imageEncoder.process(imageInput, imageAttention);
    }
    if (textEncoder) {
        if (!textInput) {
            throw new Error("Text input is not provided");
        }
        const textOutput = await textEncoder.process(textInput, textAttention, imageOutput);
        return textOutput;
    }
    return imageOutput;
};
exports.encodeData = encodeData;
async function* generate(encoderOutput, decoder, options, inputAttentionMask, initDecoderInput, initDecoderAttentionMask) {
    const sampler = (x) => greedySampler(x);
    let len = 0;
    let decoderInput = new ort.Tensor("int64", new BigInt64Array(encoderOutput.dims[0]).fill(BigInt(options.bosTokenID)), [encoderOutput.dims[0], 1]);
    let decoderAttention = new ort.Tensor("int64", new BigInt64Array(encoderOutput.dims[0]).fill(1n), [encoderOutput.dims[0], 1]);
    if (initDecoderInput) {
        decoderInput = initDecoderInput;
    }
    if (initDecoderAttentionMask) {
        decoderAttention = initDecoderAttentionMask;
    }
    const genFinished = new Array(encoderOutput.dims[0]).fill(false);
    while (true) {
        const decoderOutput = await decoder.process(encoderOutput, decoderInput, decoderAttention, inputAttentionMask);
        const newTokenIDs = sampler(decoderOutput);
        yield newTokenIDs;
        for (let i = 0; i < newTokenIDs.length; i++) {
            if (newTokenIDs[i] === options.eosTokenID) {
                genFinished[i] = true;
            }
        }
        const newDecoderTokens = [];
        const newDecoderAttention = [];
        for (let i = 0; i < decoderInput.dims[0]; i++) {
            for (let j = 0; j < decoderInput.dims[1]; j++) {
                const idx = i * decoderInput.dims[1] + j;
                newDecoderTokens.push(BigInt(decoderInput.data[idx]));
                newDecoderAttention.push(decoderAttention.data[idx]);
            }
            newDecoderTokens.push(BigInt(newTokenIDs[i]));
            if (newTokenIDs[i] === options.eosTokenID ||
                newTokenIDs[i] === options.padTokenID) {
                newDecoderAttention.push(0n);
            }
            else {
                newDecoderAttention.push(1n);
            }
        }
        decoderInput = new ort.Tensor("int64", new BigInt64Array(newDecoderTokens), [decoderInput.dims[0], decoderInput.dims[1] + 1]);
        decoderAttention = new ort.Tensor("int64", new BigInt64Array(newDecoderAttention), [decoderAttention.dims[0], decoderAttention.dims[1] + 1]);
        len += 1;
        const allGenerated = genFinished.every((x) => x);
        if ((options.maxTokens && len === options.maxTokens) ||
            (options.maxLength && len === options.maxLength) ||
            (options.eosTokenID && allGenerated)) {
            break;
        }
    }
}
exports.generate = generate;
const greedySampler = (logits) => {
    const [batchSize, seqLength, vocabSize] = logits.dims;
    const size = seqLength * vocabSize;
    const result = new Array(batchSize);
    for (let idx = 0; idx < batchSize; idx++) {
        const startIndex = (idx + 1) * size - vocabSize;
        let maxIdx = 0;
        let max = logits.data[startIndex];
        for (let i = 1; i < vocabSize; i++) {
            const l = logits.data[startIndex + i];
            if (l > max) {
                maxIdx = i;
                max = l;
            }
        }
        result[idx] = maxIdx;
    }
    return result;
};
//# sourceMappingURL=generator.js.map