"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeatureExtractionModel = void 0;
const ort = __importStar(require("onnxruntime-common"));
const common_js_1 = require("../common.js");
const utils_js_1 = require("./utils.js");
const base_js_1 = require("./base.js");
const prepare_js_1 = require("./prepare.js");
class FeatureExtractionModel extends base_js_1.BaseImageModel {
    constructor() {
        super(...arguments);
        this.process = async (inputs) => {
            if (!this.initialized || !this.preprocessor) {
                throw Error("the model is not initialized");
            }
            if (typeof inputs === "string") {
                inputs = [inputs];
            }
            if (inputs instanceof ArrayBuffer) {
                inputs = [inputs];
            }
            const tensor = await (0, prepare_js_1.prepareImagesTensor)(inputs, this.preprocessor);
            const start = new Date();
            const output = await this.runInference(tensor);
            const end = new Date();
            const elapsed = (end.getTime() - start.getTime()) / 1000;
            const result = {
                result: output,
                elapsed: elapsed,
            };
            if (output.length === 1) {
                result.result = output[0];
            }
            return result;
        };
        this.runInference = async (input) => {
            if (!this.initialized || !this.sessions) {
                throw Error("the model is not initialized");
            }
            const session = this.sessions.get("model");
            if (!session) {
                throw Error("the model is absent in the sessions map");
            }
            const feeds = {};
            const inputNames = await session.inputNames();
            feeds[inputNames[0]] = input;
            const outputData = await session.run(feeds);
            const outputNames = await session.outputNames();
            const output = outputData[outputNames[0]];
            const result = [];
            let size = 1;
            for (let i = 1; i < output.dims.length; i++) {
                size *= output.dims[i];
            }
            for (let i = 0; i < output.dims[0]; i++) {
                const partDims = output.dims.map((d) => d);
                partDims[0] = 1;
                const partData = output.data.slice(i * size, (i + 1) * size);
                const part = new ort.Tensor("float32", partData, partDims);
                const res = this.generateOutput(part);
                result.push(res);
            }
            return result;
        };
        this.generateOutput = (lastHiddenState) => {
            const tensor = new common_js_1.Tensor(lastHiddenState);
            const result = [];
            if (lastHiddenState.dims.length < 2) {
                throw Error("the model output is not valid");
            }
            if (lastHiddenState.dims.length === 3) {
                for (let i = 0; i < lastHiddenState.dims[2]; i++) {
                    result.push(0);
                }
                for (let i = 0; i < lastHiddenState.dims[1]; i++) {
                    for (let j = 0; j < lastHiddenState.dims[2]; j++) {
                        result[j] += tensor.at([0, i, j]);
                    }
                }
                for (let i = 0; i < result.length; i++) {
                    result[i] /= lastHiddenState.dims[1];
                }
                return (0, utils_js_1.normalize)(result);
            }
            else {
                for (let i = 0; i < lastHiddenState.dims[1]; i++) {
                    result.push(tensor.at([0, i]));
                }
                return (0, utils_js_1.normalize)(result);
            }
        };
    }
}
exports.FeatureExtractionModel = FeatureExtractionModel;
//# sourceMappingURL=featureExtractionModel.js.map