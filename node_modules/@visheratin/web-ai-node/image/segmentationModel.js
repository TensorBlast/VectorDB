"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SegmentationModel = void 0;
const jimp_1 = __importDefault(require("jimp"));
const base_js_1 = require("./base.js");
class SegmentationModel extends base_js_1.BaseImageModel {
    constructor() {
        super(...arguments);
        this.process = async (input) => {
            if (!this.initialized || !this.preprocessor) {
                throw Error("the model is not initialized");
            }
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            const image = await jimp_1.default.read(input);
            const tensor = this.preprocessor.process(image).tensor;
            const start = new Date();
            const output = await this.runInference(tensor);
            const end = new Date();
            const elapsed = (end.getTime() - start.getTime()) / 1000;
            const argmax = this.argmaxColors(output);
            const size = output.dims[2] * output.dims[3] * 4;
            const arrayBuffer = new ArrayBuffer(size);
            const pixels = new Uint8ClampedArray(arrayBuffer);
            for (let i = 0; i < size; i += 4) {
                const color = argmax[i / 4];
                pixels[i] = color[0];
                pixels[i + 1] = color[1];
                pixels[i + 2] = color[2];
                pixels[i + 3] = 255;
            }
            const imageData = new ImageData(pixels, output.dims[2], output.dims[3]);
            const resCanvas = this.createCanvas(imageData.width, imageData.height);
            const ctx = resCanvas.getContext("2d");
            if (ctx instanceof OffscreenCanvasRenderingContext2D ||
                ctx instanceof CanvasRenderingContext2D) {
                ctx.putImageData(imageData, 0, 0);
            }
            else {
                throw new Error("Invalid rendering context");
            }
            const result = {
                canvas: resCanvas,
                elapsed: elapsed,
            };
            return result;
        };
        this.createCanvas = (width, height) => {
            if (typeof OffscreenCanvas !== "undefined") {
                return new OffscreenCanvas(width, height);
            }
            else if (typeof document !== "undefined") {
                const canvas = document.createElement("canvas");
                canvas.width = width;
                canvas.height = height;
                return canvas;
            }
            else {
                throw new Error("Canvas creation is not supported in this environment");
            }
        };
        this.getClass = (inputColor) => {
            if (!this.initialized || !this.config) {
                throw Error("the model is not initialized");
            }
            let className = "";
            let minDiff = Infinity;
            let diff = 0;
            for (const [idx, color] of this.config.colors) {
                diff =
                    Math.abs(color[0] - inputColor[0]) +
                        Math.abs(color[1] - inputColor[1]) +
                        Math.abs(color[2] - inputColor[2]);
                if (diff < minDiff) {
                    minDiff = diff;
                    className = this.config?.classes.get(idx);
                }
            }
            return className;
        };
        this.argmaxColors = (tensor) => {
            if (!this.initialized || !this.config) {
                throw Error("the model is not initialized");
            }
            const modelClasses = this.config?.colors;
            const result = [];
            const size = 128 * 128;
            const classNumbers = new Set();
            for (let idx = 0; idx < size; idx++) {
                let maxIdx = 0;
                let maxValue = -1000;
                for (let i = 0; i < modelClasses.size; i++) {
                    if (tensor.data[idx + i * size] > maxValue) {
                        maxValue = tensor.data[idx + i * size];
                        maxIdx = i;
                    }
                }
                classNumbers.add(maxIdx);
                const color = modelClasses.get(maxIdx);
                if (!color) {
                    result.push([0, 0, 0]);
                }
                else {
                    result.push(color);
                }
            }
            return result;
        };
        this.runInference = async (input) => {
            if (!this.initialized || !this.sessions) {
                throw Error("the model is not initialized");
            }
            const session = this.sessions.get("model");
            if (!session) {
                throw Error("the model is absent in the sessions map");
            }
            const feeds = {};
            const inputNames = await session.inputNames();
            feeds[inputNames[0]] = input;
            const outputData = await session.run(feeds);
            const outputNames = await session.outputNames();
            const output = outputData[outputNames[0]];
            return output;
        };
    }
}
exports.SegmentationModel = SegmentationModel;
//# sourceMappingURL=segmentationModel.js.map